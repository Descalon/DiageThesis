\chapter{Narrative planning}
\label{ch:planning}
A lot of related work as gone into the use of a planning system that decides on the narrative structure.
Researchers like Riedl and Young~\cite{Riedl03character-focusednarrative, Riedl:2003:MIU:860575.860694, Riedl:2004:IPM:1018409.1018753} and Cavazza~\cite{Cavazza:2002:CIS:630325.630747} have been researching the use of artificial intelligence for years, and have made some interesting planning systems such as \textit{Memesis}~\cite{young2003towards}.
To help me answer my questions, I have developed my own narrative planner that tracks and generates plot points that the player can resolve to further the character's and the world's story.

\section{Actor attributes}
The most influential system within \diage are the actor attributes that specify what actors can do and how they should behave. 
On first glance these attributes are simple key-value pairs that can be used to describe a myriad of character statistics. 
Looking further the attributes can also describe behaviours that are executed whenever a actor interacts with another actor.
In essence the actors don't really interact with each other, but rather their attributes do that for them.
A simple example of an attribute would be a \textit{strength} statistic that describes how much damage the actor can do to an other entity (see figure~\ref{fig:attributeUML}).
Another example can be to add personality archetypes to an actor.
Looking at the \textit{Dungeons and Dragons} alignment table in figure~\ref{fig:dnd} we could specify that the \textit{Lawful Good} archetype will be friendly to all other actors on the \textit{Good} and \textit{Lawful} axes, but will become increasingly antagonistic towards an actor that veers towards the \textit{Evil} and \textit{Chaotic} side.

Besides specifying the actions and behaviours, the attributes can define actions that the narrator can use when planning a new story step. By looking at all attributes within the given setting the narrator can assign actors to help or obstruct the player in his current mission.
\begin{figure}[p]
 \includegraphics[scale=.7]{attributeUML}
 \caption{Class description of the DiageAttribute}\label{fig:attributeUML}
\end{figure}
\begin{figure}[p]
	\includegraphics[scale=.8]{alignment}
	\caption{\textit{Dungeons \& Dragons} alignment sheet}\label{fig:dnd}
\end{figure}

%\section{The Narrator}
%\textit{The Narrator} is the both the narrative planning system and overall controller for \diage. This section will give a brief run-down on the components that make up the Narrator.
%First and foremost are the actor attributes that specify how actors should behave in any given situation.
%On first glance these attributes are simple key-value pairs that can be used to describe a myriad of character traits on the actor, making actors behave differently according to what attributes they have.
%When actors act with each other, they do so through their attributes.
%Closely tied with the player character's attributes is the planning tracker. 
%This component tracks the history of the players actions to know how to surprise and/or comfort the player. 
%If a persistent world is used, the narrator keeps a history on all former player characters that lived within that world. 
%When \diage is used in combination with a DML-diagram, the Narrator will distribute all objects described within the diagram throughout the world. If there is no diagram specified the narrator will generate one, and continue with the normal process.
%Lastly there is the narrative planner. The planner takes a look at the current story situation, and decides what will change for the next iteration. 

\section{Initial Generation}
Depending on the input given and the desires of the developer, \diage does the initial generation of the game world and plots in varying degrees, as seen in algorithm~\ref{alg:initial_setup}.
If no input is given at all, \diage will just generate a random amount of entities to populate the world.
Input can be given either within the game code, or with a DML file (further discussed in the next chapter).
Whether specified or not, the player character needs a initial constraint.
This constraint is \his first 'objective'.
This initial constraint can be given within the input, otherwise \diage will take an entity within the world and sets that as player constraint.
Within the algorithm we see a section dedicated to custom rules.
These rules can manipulate anything within the story setting.
As an example I created a rule that randomly sets entities to a space as seen in procedure~\ref{proc:rule_example}.
The given example is purely non-deterministic, but is a simple matter to populate the spaces more evenly with the entities.
This rule system is used throughout \diage as a generalized form to give the developer more control on what a given entity can do.
\begin{algorithm}
	\KwIn{entities; customRules;}
	\KwOut{Initial world state}
	let \textit{entities} be all entities within current world state\;
	let \textit{customRules} be the custom behaviour as specified by the developer\;
	\ForEach{rule in customRules}{
		rule.Invoke();
	}
	\If{entities.count $\leq$ 0}{
		entities = GenerateRandomEntities(\textit{max})\;
	}
	\If{player.constraint == null}{
		\textbf{select random} \textit{e} \textbf{from} \textit{entities}\;
		player.constraint = \textit{e}\;
	}
    \caption{Initial planning}\label{alg:initial_setup}
\end{algorithm}
\begin{procedure}
	\tcc{Populates the spaces with the current entities within world state}
	\KwIn{entities; spaces;}
	\KwOut{All entities are randomly moved to a space}
	let \textit{entities} be all objects within current world state, excluding spaces\;
	let \textit{spaces} be all spaces within current world state\;
	\While{entities.count $>$ 0}{
		\textbf{select random} \textit{s} \textbf{from} \textit{spaces}\;
		entities.pop().MoveToSpace(s)\;
	}
	\caption{PopulateSpaces()}\label{proc:rule_example}
\end{procedure}
\section{Step Generation}
When the initial generation is complete, the player should carry out \his objective.
When the objective has been completed, the planner will automatically start a step generation\footnote{in want of a better word.
The term \textit{step} comes from cellular automata, which I'm currently working on}.
This generation is like the initial generation but uses the actor attribute system and the player as extra input.
The attribute system will be covered in a later section.
This step generation looks at all the given variables and generates a new constraint for the player(see procedure~\ref{proc:generate_constraint}).
The longer the character's life, the more exact this generation will be.
For any action taken by the player can be used in the generation.
It must be said that the actions that the planner can take needs to be specified by the author.
\begin{algorithm}
	\KwIn{entities; actors; player; customRules;}
	\KwOut{new world state}
	let \textit{entities} be all entities, excluding actors and the player\;
	let \textit{actors} be all actors, including the player\;
	\ForEach{actor in actors}{
		actor.rules.Invoke()\;
	}
	\tcc{It's possible that one of the rules gave the player a constraint, so we'll check}
	\If{player.constraint == null}{
		GenerateConstraint(player)\;
	}
	\ForEach{rule in customRules}{
		rule.Invoke()\;
	}
	\caption{Step planning}\label{alg:step_planning}
\end{algorithm}
\begin{procedure}
	\KwIn{player}
	\KwOut{new constraint for the player}
		\eIf{rules.count $\geq$ 0}{
			\ForEach{item in rules}{
				rules.invoke(player)\;
			}}{
				\textbf{select random} \textit{e} \textbf{from} \textit{entities}\;
				player.constraint = \textit{e}\;
			}
	\caption{GenerateConstraint(Player)}\label{proc:generate_constraint}
\end{procedure}
\section{Events}
Riedl and Young\cite{Riedl:2004:IPM:1018409.1018753} and Julie Porteous and Marc Cavazza\cite{Porteous:2009:CNG:1695522.1695557} have demonstrated that stories are perfectly suited to be represented as a sequence of temporal and causal events.
Porteous and Cavazza suggest to use events as a constraint for partial temporal order.
Defining operators as the following:\\\\
\begin{tabular}{|l||l|}
\hline 
operator & meaning \\ 
\hline
\hline 
\textit{sometime-before a b} & \textit{b} must be made true for the first time before \textit{a} \\ 
\hline 
\textit{sometime a} & predicate \textit{a} must be true at some stage of the narrative \\ 
\hline 
\textit{at-end a} & predicate \textit{a} must be true at the end of the narrative \\ 
\hline 
\end{tabular} 
\\\\
These operators ensure that we have some control and gives us a partial temporal order, partial because not all of the events are ordered with respect to each other.
The table is further expanded upon in their paper \textit{Controlling Narrative Generation with Planning Trajectories: the Role of Constraints}~\cite{Porteous:2009:CNG:1695522.1695557}.

The \diage planner uses event constraints like this to layer plots and direct the player on what to do next.
In the context of a \rogue we don't know when the story is going to stop, as it stops with the death of the player character.
That could be within 2 minutes, but it could be several weeks.
\diage takes this into account by keep adding segments onto a story, sometimes using information gained from previous plots and at other times creating entire new spaces and NPCs therein.
So the operators that Porteous uses we use within these small story steps instead of the entire narrative.
\diage tells us the story of the player character and how \he influenced the world around him.

\section{Planning flow}
The previous sections described the processes that \diage goes through when generating a new world.
The flowchart in figure~\ref{fig:diage_flowchart} displays the steps taken by the planner.
The initial generation influences the world by setting up spaces, actors, and objects and manipulating these entities by their specific rules.
After this, the player can, and will, influence the world by acting in it.
The planner keeps track of \his actions and saves this for future story generation \footnote{For example; a foe thought defeated returns for a rematch.}.
The step generation gets activated automatically when the player's constraint is removed, i.e.
a plot is resolved.
This can also be manually activated by the author on whatever occasion or event \he wishes.
After the step generation the player gets \his new constraint and, depending on the generative rules used, the world can be manipulated too.
Be that actors that move, or new spaces that are generated.
The step generation is highly dependant upon the player's attributes, as everything can react to the gain or loss between story steps\footnote{Mental note: one of the papers referenced this as a beat, might be a good idea!}.
The actor attributes are a powerful tool in the \diage arsenal, and the (game)world literary revolves around them.
It has to be noted, that the design of \diage works with semi-persistent worlds too.
The world data can be saved to be used in a later play-through, giving the world a whole epic of one player, and starting the next.
\begin{figure}[p]
\includegraphics[scale=.8]{diage_planner}
\caption{Simplefied Narrator flowchart}\label{fig:diage_flowchart}
\end{figure}

\section{Narrative planning in Rouge}
The Narrator plays an important part within Rouge.
From initial world building, to near continuous step generation of the story.
This step-generation takes place every turn, ensuring fast iteration on the world information present, and quick building of character and world history. 
The character specific history is used to construct behavioural patters, and remembrance of past interactions with the player character.
The latter is most interesting when using persistent worlds, where a new player character will hear stories of a former character's story. 
The goal is to eventually create legends and myths surrounding previous characters and their influence upon the world. 
The world history is to create an awareness of the world that was. 
Actors can reference locations that were previously infested with monsters, or a city that was destroyed.









